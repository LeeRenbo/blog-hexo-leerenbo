---
title: JSR107-缓存标准解读
date: 2017-10-23 10:58:38
tags:
---
# 1.概述
jsr107是本地缓存标准的API，用于创建、访问、更新、删除缓存中的数据。
缓存能显著的提升，从多数据源，网络服务，高计算的性能。
部分功能与分布式缓存不相适应。
    
## 1.1 JSR107目标
* 为应用程序提供缓存功能，特别是缓存Java对象的能力
* 定义一套通用的缓存概念和设施;
* 最大限度地减少Java开发人员需要学习采用缓存的概念数量
* 最大化在缓存实现之间使用缓存的应用程序的可移植性
* 支持进程内和分布式缓存实现
* 支持通过值缓存和引用缓存Java对象
* 根据JSR-175：Java编程语言的元数据设施定义运行时高速缓存注释; 以便使用可选提供的注释处理器的Java开发人员可以声明性地指定应用程序缓存要求;

## 1.2 非JSR107目标
* 资源和内存约束配置 - 虽然许多高速缓存实现提供了对缓存可以在运行时使用的资源量的限制的支持，但本规范并未定义如何配置或表示此功能。 然而，这个规范确定了一个标准的机制，用于开发人员指定可以使用多长时间缓存的信息。
* 缓存存储和拓扑 - 此规范不指定缓存实现如何存储或表示缓存的信息。
* 管理 - 本规范不指定缓存的管理方式。 它确定了通过Java管理扩展（JMX）以编程方式配置缓存并调查高速缓存统计信息的机制。
* 安全性 - 本规范不规定缓存内容如何得到保护，以及如何控制缓存中的访问和操作。
* 外部资源同步 - 本规范不规定应用程序或缓存实现如何使缓存和外部资源内容保持同步。

# 2.基础
## 2.1核心概念
* CachingProvider - 定义了建立，配置，获取，管理和控制零个或多个 CacheManager(s) 的机制。 应用程序可以在运行时访问和使用零个或多个CachingProvider。
* CacheManager - 定义了在CacheManager的上下文中建立，配置，获取，管理和控制零个或多个唯一命名的 Cache(s) 的机制。 CacheManager由单个CachingProvider拥有。
* Cache - 缓存是一个类似 Map 的数据结构，允许临时存储基于键的值，一些像java.util.Map数据结构一样。 缓存由单个CacheManager拥有。
* Entry - 是由Cache存储的单个键值对。
* ExpiryPolicy - 由缓存存储的每个条目具有定义的持续时间，称为到期时间，在此期间，可以访问，更新和删除它们。 一旦这个持续时间过去，该条目据说已过期。 一旦过期，条目将不再可用于访问，更新或删除，就像它们从不存在于缓存中一样。 Expiry使用ExpiryPolicy设置。

## 2.2 Cache 和 Map
虽然缓存和 Map 共享一些类似的API，但缓存不是 Map 。Map 不是高速缓存。 以下部分概述了主要的相似之处和差异。

### 相似
* 通过关联的 key 存储和访问值。
* 每个 key 只能与缓存中的单个值相关联
* 如果使用可变对象作为关键字，则必须非常小心。 当 Cache 使用 key 时, 并在操作时修改了 key 的 equal 对比，则Cache的行为是未定义的。
* 缓存依赖相等的概念来决定，keys和values是否相同。所以key和value类应该定义合适的 Object.hashCode 的实现

### 不同
* 缓存键和值不能为空。对于键或值使用null的任何尝试将导致抛出NullPointerException，而不管使用何种。
* 条目可过期。
* 条目可驱逐。资源有限，缓存的是数据子集，超出资源大小删除条目称驱逐。驱逐策略 LRU等。
    ```
    规范中没有定义容量的一些原因是：
    - 实现可以利用多层分层存储结构，并因此定义每层的容量。 在这种情况下，无法定义缓存的总体容量，这样做是不明确的。
    - 实现可以以字节而不是每个层上的条目计数来定义容量。
    - 使用的内存条目的相对成本与运行时的条目的实现的内部表示直接相关。
    ```
* 为了支持 compare-and-swap（CAS）操作，那些原子比较和交换值的定制值类应该提供一个适当的Object.equals实现。
* 实现可能需要按键和值以某种方式可序列化。
* 可以配置缓存，控制条目的存储方式，使用值缓存或可选地使用引用缓存。
* 实现可以可选地执行安全限制。 如果发生违规，则必须抛出SecurityException异常。

## 2.3 一致性
一致性是指当多个线程访问高速缓存时，高速缓存的行为和并发缓存突变发生时存在的保证以及突变的可见性。
所有实现必须支持如下所述的默认一致性模型。

### 2.3.1 默认一致性

当使用默认一致性模式时，大多数缓存操作的执行方式就像 Cache 中每个 Key 存在锁定机制一样。当缓存操作获取对 key 的排他读写锁时，该 key 的所有后续操作将被阻塞，直到该锁被释放。结果是由线程执行的操作发生在由另一个线程执行的读取或变更操作之前，包括不同Java虚拟机中的线程。
这可以被理解为一种悲观的锁定方法。锁定，变更和解锁。

对于某些缓存操作，缓存返回的值被认为是最后一个值。最后一个值可能是旧值或新值，特别是在同时更新条目的情况下。它是依赖于实现的返回。
这可以被理解为没有保证一致性的无锁方法。


其他操作遵循不同的约定，因为突变可能仅在条目的当前状态与期望状态匹配时才发生。在这样的操作中，多个线程可以自由竞争来应用这些改变，就像它们共享一个锁一样。这些是：

* boolean putIfAbsent(K key, V value);
* boolean remove(K key, V oldValue);
* boolean replace(K key, V oldValue, V newValue); 
* boolean replace(K key, V value);
* V getAndReplace(K key, V value);

这可以被理解为乐观的锁定方法; 只有当状态匹配已知状态时，才应用更改，否则失败。 这些类型的操作也称为比较和交换（CAS）操作，在CPU指令也以此方式操作。
由于这些方法必须与其他缓存操作相互作用，表现就像它们具有排他锁一样.不装作拥有排它锁，CAS方法不能写入新的值。
因此，在默认的一致性的情况下，CAS方法可以允许更高级别的并发性，但它们将被非CAS方法所阻止。

下表显示了适用于每个Cache方法的默认一致性：


|Method                                         |Default Consistency|
|-----------------------------------------------|-------------------|
|boolean containsKey(K key)                     |last value         |
|V get(K key)                                   |happen-before      |
|Map<K,V> getAll(Collection<? extends K> keys)  |happen-before for each key individually but not for the Collection.|
|V getAndPut(K key, V value)                    |happen-before      |
|V getAndRemove(K key)                          |happen-before      |
|V getAndReplace(K key, V value)                |happen-before plus compare and swap|
|CacheManager getCacheManager()                 |N/A                |
|CacheConfiguration getConfiguration()          |N/A                |
|String getName()                               |N/A                |
|Iterator<Cache.Entry<K, V>> iterator()         |last value         |
|void loadAll(Set<? extends K> keys, boolean replaceExistingValues, CompletionListener listener)|N/A|
|void put(K key, V value)                       |happen-before      |
|void putAll(Map<? extends K,? extends V> map)  |happen-before for each key individually but not for the Collection.|
|boolean putIfAbsent(K key, V value)            |happen-before plus compare and swap|
|boolean remove(K key)                          |happen-before      |
|boolean remove(K key, V oldValue)              |happen-before plus compare and swap|
|void removeAll()                               |last value         |
|void removeAll(Set<? extends K> keys)          |happen-before for each key individually but not for the Collection.|
|<T> T invoke(K key, EntryProcessor<K, V, T> entryProcessor, Object... arguments)entryProcessor)|happen-before|
|<T> Map<K, EntryProcessorResult<T>> invokeAll(Set<? extends K> keys, EntryProcessor<K, V, T> entryProcessor, Object... arguments)|happen-before for each key individually but not for the Collection.|
|boolean replace(K key, V value)                |happen-before plus compare and swap|
|boolean replace(K key, V oldValue, V newValue) |happen-before plus compare and swap|
|<T> T unwrap(Class<T> cls)                     |N/A                |


## 2.4 缓存拓扑
虽然该规范并不要求特定的缓存拓扑，但是认识到Cache条目可以很好地被本地存储和/或分布在多个进程中。 实施可能选择不支持，一种，两种和/或其他拓扑。



















